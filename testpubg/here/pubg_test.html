<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - buffergeometry</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #cccccc;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #050505;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #0080ff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - buffergeometry</div>

		<script src="../build/three.js"></script>

		<script src="js/Detector.js"></script>
		
		<script src="js/controls/OrbitControls.js"></script>

		<script src="js/libs/stats.min.js"></script>

		<script>

			(function() {
    'use strict';
    // 'To actually be able to display anything with Three.js, we need three things:
    // A scene, a camera, and a renderer so we can render the scene with the camera.'
    // - https://threejs.org/docs/#Manual/Introduction/Creating_a_scene

    var scene, camera, renderer;

    // I guess we need this stuff too
    var container, HEIGHT,
        WIDTH, fieldOfView, aspectRatio,
        nearPlane, farPlane, stats,
        geometry, particleCount,
        i, h, color, size,
        materials = [],
        mouseX = 0,
        mouseY = 0,
        windowHalfX, windowHalfY, cameraZ,
        fogHex, fogDensity, parameters = {},
        parameterCount, particles;


    var loader = new THREE.FileLoader();
    var controls ;


    init();
    animate();



    function init() {

        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        windowHalfX = WIDTH / 2;
        windowHalfY = HEIGHT / 2;

        fieldOfView = 75;
        aspectRatio = WIDTH / HEIGHT;
        nearPlane = 1;
        farPlane = 10000;


        renderer = new THREE.WebGLRenderer(); /*	Rendererererers particles.	*/
        renderer.setPixelRatio(window.devicePixelRatio); /*	Probably 1; unless you're fancy.	*/
        renderer.setSize(WIDTH, HEIGHT); /*	Full screen baby Wooooo!	*/

        /* 	fieldOfView — Camera frustum vertical field of view.
	aspectRatio — Camera frustum aspect ratio.
	nearPlane — Camera frustum near plane.
	farPlane — Camera frustum far plane.

	- https://threejs.org/docs/#Reference/Cameras/PerspectiveCamera

	In geometry, a frustum (plural: frusta or frustums)
	is the portion of a solid (normally a cone or pyramid)
	that lies between two parallel planes cutting it. - wikipedia.		*/

        cameraZ = 1000; /*	So, 1000? Yes! move on!	*/
        fogHex = 0x000000; /* As black as your heart.	*/
        fogDensity = 0.0001; /* So not terribly dense?	*/

        //camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);
        
		camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.set( 0, 20, 100 );
        controls = new THREE.OrbitControls( camera, renderer.domElement );

        controls.enableDamping = true;
		controls.dampingFactor = 0.25;

        //camera.position.z = cameraZ;

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(fogHex, fogDensity);

        container = document.createElement('div');
        document.body.appendChild(container);
        document.body.style.margin = 0;
        document.body.style.overflow = 'hidden';

        //952950
        particleCount = 952950; /* Leagues under the sea */

        /*	Hope you took your motion sickness pills;
	We're about to get loopy.	*/

      
        /*	We can't stop here, this is bat country!	*/

      





			// load a resource
			loader.load(
				// resource URL
				"models/json/smaller_pubg.json",

				// onLoad callback
				function ( obj2 ) {

					var obj = JSON.parse(obj2)
					console.log(obj.data.length);

					geometry = new THREE.Geometry(); /*	NO ONE SAID ANYTHING ABOUT MATH! UGH!	*/



					  for (i = 0; i < particleCount; i++) {

		            var vertex = new THREE.Vector3();
		            vertex.x = obj.data[i].killer_position_x;
		            vertex.y = obj.data[i].killer_position_y;
		            vertex.z = obj.data[i].heihgtxy*0.01;
		            //console.log(vertex.z);

		            geometry.vertices.push(vertex);

		            }

		              parameters = [
				            [
				                [1, 1, 0.5], 0.5
				            ],
				            [
				                [0.95, 1, 0.5], 0.5
				            ],
				            [
				                [0.90, 1, 0.5], 0.5
				            ],
				            [
				                [0.85, 1, 0.5], 0.5
				            ],
				            [
				                [0.80, 1, 0.5], 0.5
				            ]
				      	];
       			 parameterCount = parameters.length;

        /*	I told you to take those motion sickness pills.
	Clean that vommit up, we're going again!	*/

		        for (i = 0; i < parameterCount; i++) {

		            color = parameters[i][0];
		            size = parameters[i][1];

		            materials[i] = new THREE.PointsMaterial({
		                size: size
		            });

		            particles = new THREE.Points(geometry, materials[i]);
		            // particles.position.x=0;
		            // particles.position.y=0;
		            // particles.position.z=0;

		            //particles.rotation.x = Math.random() * 6;
		            //particles.rotation.y = Math.random() * 6;
		            //particles.rotation.z = Math.random() * 6;

		            scene.add(particles);
		        }

		        geometry.computeBoundingBox();
		        geometry.center();


		        controls.update();

					// var material = materials[ 0 ];
					// var object = new THREE.Mesh( geometry, material );
					// scene.add( object );
				},

				// onProgress callback
				function ( xhr ) {
					console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
				},

				// onError callback
				function( err ) {
					console.log( 'An error happened' );
				}
			);





        /*	If my calculations are correct, when this baby hits 88 miles per hour...
	you're gonna see some serious shit.	*/

      

        container.appendChild(renderer.domElement); /* Let's add all this crazy junk to the page.	*/

        /*	I don't know about you, but I like to know how bad my
		code is wrecking the performance of a user's machine.
		Let's see some damn stats!	*/

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        stats.domElement.style.right = '0px';
        container.appendChild(stats.domElement);

        /* Event Listeners */

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('touchstart', onDocumentTouchStart, false);
        document.addEventListener('touchmove', onDocumentTouchMove, false);

    }

    function animate() {
        requestAnimationFrame(animate);

        render();
        stats.update();
    }

    function render() {
        var time = Date.now() * 0.00005;

         //controls.update();


        //camera.position.x += (mouseX - camera.position.x) * 0.1;
       //camera.position.y += (-mouseY - camera.position.y) * 0.1;

        //camera.lookAt(scene.position);

        for (i = 0; i < scene.children.length; i++) {

            var object = scene.children[i];

            // if (object instanceof THREE.PointCloud) {

            //     object.rotation.y = time * (i < 4 ? i + 1 : -(i + 1));
            // }
        }

        for (i = 0; i < materials.length; i++) {

            color = parameters[i][0];

            h = (360 * (color[0] + time) % 360) / 360;
            materials[i].color.setHSL(h, color[1], color[2]);
        }

        renderer.render(scene, camera);
    }

    function onDocumentMouseMove(e) {
        mouseX = e.clientX - windowHalfX;
        mouseY = e.clientY - windowHalfY;
    }

    /*	Mobile users?  I got your back homey	*/

    function onDocumentTouchStart(e) {

        if (e.touches.length === 1) {

            e.preventDefault();
            mouseX = e.touches[0].pageX - windowHalfX;
            mouseY = e.touches[0].pageY - windowHalfY;
        }
    }

    function onDocumentTouchMove(e) {

        if (e.touches.length === 1) {

            e.preventDefault();
            mouseX = e.touches[0].pageX - windowHalfX;
            mouseY = e.touches[0].pageY - windowHalfY;
        }
    }

    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
})();

		</script>

	</body>
</html>
